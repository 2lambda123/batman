\documentclass[12pt,preprint]{aastex} 
%\documentclass[apjl]{emulateapj}
\usepackage{amsmath}
\usepackage{color}
%\usepackage{hyperref}

\newcommand*{\blue}{\textcolor{blue}}

\shortauthors{Kreidberg}

\begin{document}

\title{BATMAN}

\author{Laura Kreidberg\altaffilmark{1,2}}

\email{E-mail: laura.kreidberg@uchicago.edu}

\altaffiltext{1}{Department of Astronomy and Astrophysics, University of Chicago, 5640 S.~Ellis Ave, Chicago, IL 60637, USA}
\altaffiltext{2}{National Science Foundation Graduate Research Fellow}

\begin{abstract}
I introduce \texttt{batman}, a Python package for calculating exoplanet transit light curve models.
\end{abstract}


\keywords{planets and satellites: atmospheres --- planets and satellites:  composition --- planets and satellites: individual: WASP-12b}

\section{Introduction}
When an extrasolar planet transits in front of its host star, a small fraction of the stellar flux is blocked by the planet.  Precise measurements of stellar brightness as a function of time (light curves) can therefore reveal transiting planets. Over a thousand planets have been discovered with this technique \citep[e.g.][]{rowe2015}.  Transit light curves can be used to characterize the planets in detail, enabling measurements of planetary radius, orbital elements, and even atmospheric temperature structure and composition \citep{seager00, seager03}.  %This characterization depends on a foundation of accurate transit light curve models. 

Even though transit light curve models are a very basic part of the toolkit for exoplanet characterization, they are not trivial to compute.  The model must account for the planet's size and position on the sky, as well as stellar limb darkening, which causes the apparent brightness of the stellar disk to decrease from center to edge.  The  stellar intensity profile can be fit with several functional forms, including a linear limb darkening law \citep{schwarzschild06}, quadratic \citep{kopal50}, square-root \citep{diaz-cordoves92}, logarithmic \citep{klinglesmith70}, exponential \citep{claret03}, and four-parameter nonlinear \citep{claret00}.  For some of these profiles, model transit light curves can be calculated analytically \citep{mandel02, gimenez06, abubekerov13}.  Other profiles do not have analytic solutions, and models must be calculated by numeric integration of the stellar intensity over the disk of the planet. 

A number of codes are available to calculate transit light curves. \cite{mandel02} provide Fortran/IDL routines to compute models for quadratic and nonlinear limb darkening laws. The software packages \texttt{TAP} \citep{gazak12} and \texttt{EXOFAST} \citep{eastman13} include IDL implementations of the \cite{mandel02} algorithm for quadratic limb darkening. \texttt{JKTEBOP} calculates models in Fortran for a broad range of limb darkening laws \citep{southworth04}. \cite{kjurkchieva13} introduce the pure Python code \texttt{TAC-maker}, which performs numeric integration for arbitrary limb darkening profiles. There are also routines available to model simultaneous transits by one or more bodies \citep{kipping11, pal12}.  Most recently, \cite{parvianinen15} released the Python package \texttt{PyTransit}, which implements analytic models from \cite{mandel02} and \cite{gimenez06}.  

In this paper, I introduce the Python package \texttt{batman}.  This package enables fast computation of transit light curves for uniform, linear, quadratic, logarithmic, exponential, and nonlinear limb darkening laws. Light curves for the first three of these are calculated analytically based on the formalism from \cite{mandel02}.  Models for the remaining limb darkening cases are computed with an efficient new integration scheme, described in \S\,\ref{section:algorithm}. I discuss \texttt{batman}'s features and performance in \S\,\ref{section:batman} and conclude in \S\,\ref{section:conclusion}.

%This package implements an efficient new algorithm (described in \S\,\ref{section:algorithm}) to calculate transit light curve models for any radially symmetric limb darkening profile.  The transit models are computed with C extension modules written with the Python/C API, and the code is parallelized at the C level with OpenMP.  The package therefore   mostly widely used programming language


\section{Algorithm}
\label{section:algorithm}
To calculate the fraction $\delta$ of stellar flux blocked by a transiting planet, one must integrate the sky-projected intensity of the star ($I$) over the area obscured by the disk of the planet ($S$):
\begin{equation}
\delta = \iint_S{I \mathrm{d}S}
\label{eqn:surfaceint}
\end{equation}
where $I$ is normalized such that the integrated intensity over the stellar disk is unity. This expression is valid for any general stellar surface brightness map; however, it is slow to evaluate numerically because the differential area elements must be small ($\lesssim 10^{-6}$) in order to achieve better than one part per million (ppm) accuracy.

On the other hand, if the stellar intensity profile is radially symmetric, the two-dimensional calculation in Equation\,\ref{eqn:surfaceint} can be reduced to one dimension and sped up greatly with the following algorithm: 
\begin{equation}
\delta = \sum_{i=1}^{n} I\left(\frac{x_i+x_{i-1}}{2}\right) \left[A(x_{i}, r_p, d) - A(x_{i-1}, r_p, d)\right]
\end{equation}
where $x$ is the normalized radial coordinate $0 < x < 1$, $I(x)$ is the 1D stellar intensity profile, $r_p$ is the planetary radius, $d$ is the separation of centers between the star and the planet, and $A(x, r_p, d)$ is the area of intersection between two circles of radii $x$ and $r_p$, separated by a distance $d$.  The sum is carried out over the range $x_0 = d - r_p$ to $x_n = \textrm{MIN}(d + r_p, r_s)$, where $r_s$ is the stellar radius.  The intersecting area is given by:

\begin{equation}
A(x, r_p, d) = 
\begin{cases}
x^2\cos^{-1}{u} + r_p^2\cos^{-1}{v} - 0.5\sqrt{w}, & r_p -d < x < r_p + d\\
x^2, & x \le r_p - d\\
r_p^2 & x \ge r_p +d \\
\end{cases}
\end{equation}
where
\begin{eqnarray}
u &=& (d^2+x^2-r_p^2)/(2dx)\\
v &=& (d^2 + r_p^2 -x^2)/(2dr_p) \\
w &=& (-d+x+r_p)(d+x-r_p)(d-x+r_p)(d+x+r_p).
\end{eqnarray}

See Figure\,\ref{fig:integration} for a schematic illustrating the geometry of the integration.  The advantage of this integration scheme is that the only error introduced is due to approximating the stellar intensity as constant over the differential area element $\Delta A = A(x_i, r_p, d) - A(x_{i-1}, r_p, d)$.  Computation of $\Delta A$ is expensive, but it needs to be calculated relatively few times ($<<10^{6}$ for sub-ppm accuracy). This makes the integration faster than one with a simpler area element (e.g., $\Delta A = \Delta x \Delta y$), that requires a much smaller step size to achieve the same accuracy.

The integration can be further optimized by using a nonuniform step size.  Typical stellar intensity profiles have larger gradients near the limb of the star than at the center \citep[e.g.][]{claret00}, so smaller steps are required at larger $x$ values to achieve the same accuracy.  I adopt the following step-size scaling: 
$$
x_i - x_{i-1}  = f\cos^{-1}\left(x_{i-1}\right)
$$  
where $f$ is a constant scale factor. This prescription is fast to compute and well-behaved at the limits $x=0$ and $x=1$.


\begin{figure}
\resizebox{\hsize}{!}{\includegraphics{f1.pdf}}
\caption{Schematic illustration of the integration scheme. The star (large black circle; partially visible) has a radius of 1 and is centered in the plane of the sky at ($x$, $y$) = (0, 0). The planet (smaller black circle) is separated from the center of the stellar disk by a distance $d$ (marked by the solid black line).  The star is partitioned into concentric circles (dotted lines) in order to calculate the integral over the planet disk.  A single integration element $\Delta A$ is shaded in orange. The integration step size illustrated here is larger than for a typical calculation for visual clarity.  Note that because the stellar intensity profile is radially symmetric, the coordinate system can be chosen such that the planet lies on the x-axis, as shown.}
\label{fig:integration}
\end{figure}

\section{The \texttt{batman} package}
The Python package \texttt{batman} implements the algorithm described in \S\,\ref{section:algorithm} to calculate model transit light curves.  \texttt{batman} is an open source project and is being developed on GitHub.  Full documentation is available at \blue{\url{https://github.com/lkreidberg/batman}}. I summarize the main capabilities of the package here.

\subsection{Limb-Darkening Models}
\texttt{batman} supports calculation of exoplanet transit light curves for uniform, linear \citep{schwarzschild06}, quadratic \citep{kopal50}, square-root \citep{diaz-cordoves92}, logarithmic \citep{klinglesmith70}, exponential \citep{claret03}, and nonlinear \citep{claret00} stellar intensity profiles:
\begin{align}
  I(\mu) &= I_0                                                                         & &\text{(uniform)}             \\
  I(\mu) &= I_0[1 - c_1(1-\mu)]                                                         & &\text{(linear)}              \\
  I(\mu) &= I_0[1 - c_1(1 - \mu) - c_2(1-\mu)^2]                                        & &\text{(quadratic)}           \\
  I(\mu) &= I_0[1 - c_1(1 - \mu) - c_2(1-\sqrt{\mu})]                                   & &\text{(square-root)}         \\
  I(\mu) &= I_0[1 - c_1(1 - \mu) - c_2\mu\ln{\mu}]                                      & &\text{(logarithmic)}         \\
  I(\mu) &= I_0\left[1 - c_1(1 - \mu) - c_2/(1-\exp{\mu})\right]                  	& &\text{(exponential)}         \\
  I(\mu) &= I_0[1 - c_1(1-\mu^{1/2}) - c_2(1- \mu) - c_3(1-\mu^{3/2}) - c_4(1-\mu^2)]   & &\text{(nonlinear)}
\end{align}
where $\mu = \sqrt{1-x^2}$ and $c_1, ..., c_n$ are limb darkening coefficients.  The \texttt{batman} source distribution also includes a template for the creation of a custom profile for any radially symmetric function.  

The square-root, logarithmic, exponential, nonlinear, and custom models are computed with the numeric integration scheme from \S\,\ref{section:algorithm}.  The uniform, linear, and quadratic models are calculated analytically, with code based on the Fortran routines \texttt{occultquad.f} and \texttt{occultuniform.f} provided by \cite{mandel02}.  

\subsection{Accuracy}
For models calculated by integration, the user can specify the maximum allowable truncation error with the \texttt{max\_err} parameter.  When a transit model is initialized, the integration step size is tuned such that the difference between the model and a high-accuracy template (calculated with scale factor $f = 10^{-4}$) is below the specified tolerance.  The lower limit on achievable accuracy with this method is below $10^{-10}$ for typical limb darkening profiles. Figure\,\ref{fig:transit} shows an example transit light curve and its truncation error.

\begin{figure}
\resizebox{\hsize}{!}{\includegraphics{f2.pdf}}
\caption{An example transit light curve for a nonlinear stellar intensity profile (top panel) and truncation error for the calculation (bottom panel).  The error tolerance parameter \texttt{max\_err} was set to 1.0 parts per million.  The truncation error increases with distance from the center of the star up to around $\pm0.2$ hours from the time of mid-transit, because the stellar intensity gradient is larger at larger radii. The error decreases again during ingress and egress as the planet eclipses a smaller fraction of the stellar disk.}
\label{fig:transit}
\end{figure}

\subsection{Separation of Centers}
One of the required inputs for a transit model is the separation of centers $d$ between the star and the planet.  \texttt{batman} computes $d$ automatically from the following set of user-specified parameters: planet semi-major axis, orbital inclination, eccentricity, longitude of periastron, orbital period, and time of periastron/mid-transit time (for eccentric/circular orbits). FIXME add refs to eqns in Seager 10. 



\subsection{Performance}
\begin{figure}
\resizebox{\hsize}{!}{\includegraphics{f3.pdf}}
\caption{Execution time as a function of truncation error tolerance for a nonlinear model (black curve), compared to the execution time for a quadratic model (dashed gray line). FIXME finish.}
\label{fig:performance}
\end{figure}
The computationally intensive sections of the code (including all of the transit model calculation) are written as C extension modules with the Python/C API, which improves the performance by roughly two orders of magnitude over a pure Python implementation.  The code also includes the option to parallelize at the C level with OpenMP, which further speeds up the calculation. The number of processors is specified by the user with the parameter \texttt{nthreads}.  \texttt{batman} will raise an exception if the user attempts to parallelize a calculation on a system where OpenMP is not supported.

I tested \texttt{batman}'s performance over a range of typical use cases using a 1.7 GHz Intel Core i5 processor.  In Figure\,\ref{fig:performance}, I show the execution time versus error tolerance for a single transit light curve calculation using a nonlinear intensity profile, compared to the execution time for a quadratic model computed analytically.  The test case consists of 100 points evenly sampled in time during the planet's transit. I used physical parameters from the GJ 1214b system \citep{kreidberg14a}. The stellar intensity profile is the same for the nonlinear and quadratic models: the nonlinear limb darkening coefficients are $[0.0, 0.7, 0.0, -0.3]$ and the quadratic coefficients are $[0.1, 0.3]$.  For this case, reaching a truncation error of 1.0 ppm via integration is just 2.5 times slower than the analytic calculation. FIXME add what the power law relation for timing is.

\subsection{Comparison with Analytic Models for Nonlinear Limb Darkening}
I explored using an analytic model to calculate transit light curves for the four-parameter nonlinear limb darkening profile.  The analytic solution for nonlinear limb darkening was presented in \cite{mandel02}, but it is not used in any published software packages; the original code provided by \cite{mandel02} uses numeric integration.   I tested a Python/C implementation of the \cite{mandel02} algorithm and found that the new integration scheme in \S\,\ref{section:algorithm} is over 20 times faster (for a truncation error tolerance of 1 ppm).

The analytic solution is challenging to compute because it uses the Appell F1 hypergeometric function.  This function is only convergent for certain regions of parameter space and must be calculated with analytic continuation for other cases. \cite{colavecchia04} provide a Fortran library for computing Appell F1.  I used this library to implement the analytic model for nonlinear limb darkening but did not achieve good results. The returned Appell F1 values are not accurate for all input parameters (based on a comparison with \texttt{Mathematica} and the pure Python library \texttt{mpmath}).  Even for cases where F1 is correct, the computation is FIXME times slower than numeric integration (for an error tolerance of FIXME).  I concluded that integration is a faster and easier solution than analytic models for nonlinear limb darkening.

\section{Summary}
%In this paper I introduced the \texttt{batman} package.
%in preparation for ultra-precise light curves from future telescopes.
%now have transit model that is good enough for JWST

\acknowledgments

\bibliographystyle{apj}
\bibliography{ms.bib}

\end{document}

